PYTHON

LED
from environment import *
from physical import *
from gpio import *
from time import *
from pyjs import *

MAX_LIGHT_PERCENT = 1
VOLUME_AT_RATE = 100000
value = 0

def setup():
    setComponentOpacity("black", 1)
    add_event_detect(0, isr)
    isr()


def isr():
    global value
    analoginput = analogRead(0)
    value = js_map(analoginput, 0, 1023, 0, 1)
    setComponentOpacity("black", 1-value)
    setDeviceProperty(getName(), "level",analoginput)



def main():
    setup()
    while True:
        updateEnvironment()
        delay(1000)


def updateEnvironment():
    global value
    global MAX_LIGHT_PERCENT
    global VOLUME_AT_RATE
    rate = float(value*MAX_LIGHT_PERCENT*VOLUME_AT_RATE) / Environment.getVolume()
    # rate equals limit because we want it to happen immediately
    Environment.setContribution("Visible Light", rate, rate, False)

if __name__ == "__main__":
    main()



BLUETOOTH SPEAKER

from gpio import *
from time import *
from ioeclient import *
from physical import *
from bluetooth import *
import math

dstService = "{58c41a2f-5111-45b0-863c-0429591c81fd}"
btService = BluetoothService()
state = 0
active = 0

def setup ():
    IoEClient.setup({
        "type": "Bluetooth Speaker",
        "states": [{
            "name": "Connected",
            "type": "bool",
            "controllable": False
        },
        {
            "name": "Playing",
            "type": "bool",
            "controllable": False
        }]
    })
    global state
    global active
    global dstService
    global blueTooth
    state = restoreProperty("state", 0)
    active = restoreProperty("active", 0)

    destroySounds()
    Bluetooth.init()
    Bluetooth.setAcceptingPairRequest(True)
    Bluetooth.setDiscoverable(True)
    print btService.start(dstService)


def restoreProperty(propertyName, defaultValue):
    value = getDeviceProperty(getName(), propertyName)
    if  not (value == "" or value == None):
        if  type(defaultValue) is int :
            value = int(value)

        setDeviceProperty(getName(), propertyName, value)
        return value
    return defaultValue

def main ():
    setup()
    while True:
        updateState()
        delay(1000)


def updateState ():
    global state
    global active
    if float(active) == 0:
        digitalWrite(1, LOW)
    else:
        digitalWrite(1, HIGH)

    report = str(state) + "," + str(active)
    IoEClient.reportStates(report)
    setDeviceProperty(getName(), "state", state)
    setDeviceProperty(getName(), "active", active)


def playMusic (sound):
    global active
    destroySounds()
    addSound("music", sound)
    playSound("music", -1)
    active = 1
    digitalWrite(1, HIGH)


def stopMusic ():
    global active
    destroySounds()
    active = 0
    digitalWrite(1, LOW)

def onAcceptPairRequestDone(mac, deviceName):
    print "accepting pair request: " + str(mac)
    Bluetooth.acceptPairRequest(mac, deviceName)
    

def onDevicePairDone(mac):
    global state
    print "paired: " + str(mac)
    state = 1
    

def onDeviceUnpairDone(mac):
    global state
    print "unpaired: " + str(mac)
    stopMusic()
    state = 0
    

def onDeviceConnectDone(mac):
    global state
    print "connected: " + str(mac)
    state = 1
    

def onDeviceDisconnectDone(mac):
    global state
    print "disconnected: " + str(mac)
    stopMusic()
    state = 0
    

def onReceiveDone(srcMac, srcService, dstMac, dstService, data):
    print "received from " + srcMac + ":" + srcService + ": " + data
    if len(data) > 0:
        playMusic(data)
    else:
        stopMusic()
        
btService.onReceive(onReceiveDone)
Bluetooth.onDeviceDisconnect(onDeviceDisconnectDone)
Bluetooth.onDeviceConnect(onDeviceConnectDone)
Bluetooth.onDevicePair(onDevicePairDone)
Bluetooth.onDeviceUnpair(onDeviceUnpairDone)
Bluetooth.onPairRequest(onAcceptPairRequestDone)

if __name__ == "__main__":
    main()




HUMITURE SENSOR
from gpio import *
from time import *
from physical import *
from environment import *
from pyjs import *
import math

# Purpose:
# Humiture sensor.  Check environmental values to determine the humiture.

# Environment must have these two variables in order for this object to work.
# The tempurature must be in degrees fahrenheit.
TEMPERATURE_NAME = "Ambient Temperature"
HUMIDITY_NAME = 'Humidity'
MIN = 0
MAX = 100

# How temperatures are represented in the Environment.
# If you are storing temperature as C then this would be true.
# If as F then false.  This way the script knows how to convert it when reading from the environment.
METRIC = True

def main():
    while True:
	    loop()

# Purpose:
# Update function.  Occures once each update.  Limits how over the temerature is detected to speed up the operation.
def loop():
    detect()
    delay(1000)


# Detects when how temperature is stored in then environment is changed.
# Updates the display and handles the correct measurement type (F or C)
def measurementSystemChangeEvent():
    METRIC = isUsingMetric()
    detect()


# Purpose:
# Check the environmental value and calculate and display the humiture.
def detect():
    temperature = Environment.get(TEMPERATURE_NAME)
    humidity = Environment.get(HUMIDITY_NAME)
    if 0 > humidity:
        humidity = 0

    if METRIC == True:
        temperature = (temperature * 1.8) + 32

    updateHumiture(temperature,  humidity)



# Purpose:
# Compute the humature and update the text display.
def updateHumiture(temperature, humidity):
    global MIN
    global MAX
    result = float(temperature + humidity)/2
    if result < MIN:
        result = MIN
    elif result > MAX:
        result = MAX
    setDeviceProperty(getName(), "level", math.floor(result + .5))
    result = math.floor(js_map(result, MIN, MAX, 0, 255))
    analogWrite(A0, result)

if __name__ == "__main__":
    main()




SOLAR PANEL IOT4
from options import Options
from time import *
import math
from physical import *
from gpio import *
from environment import Environment
from ioeclient import IoEClient
#from pyjs import *


#Solar Panel
#Read the sunlight levels
#Output electricity based on sunlight
#Panel will be 160Watts per square meter

#Features output to IoE Server:
# number of kWh of energy produced since turning on
# number of kWh per minute
# current production
ENVIRONMENT_NAME = "Sunlight"        # var ENVIRONMENT_NAME
MULTIPLIER = 255. / 1023        # var MULTIPLIER
MAX_POWER = 1000. #1000 Watts of power based on one meter solar panel at noon at the equator        # var MAX_POWER
EFFICIENCY = 0.16 #About a 16 percent efficiency per solar panel        # var EFFICIENCY
PANEL_POWER = MAX_POWER * EFFICIENCY        # var PANEL_POWER
LOG_BASE = 1.0749111034571373359815489867558        # var LOG_BASE

state = 1        # var state
electricity = 0        # var electricity
#tick = 0        # var tick


def setup ():
    
    IoEClient.setup({
        "type": "Solar",
        "states": [{
            "name": "Status",
            "type": "number",
            "unit": 'Wh',
            "controllable": False
        }]
    })

    IoEClient.onInputReceive ( lambda rinput: processData(rinput, True) )

    sendReport()




def loop ():
    global electricity
    ##    if  (tick++ % 10) is 0 )    # is tick consistent across devices?
    ##    {
    electricity = int(getElectricityProduction())
    ##print(electricity)
    displayElectricity()
    sendReport()
    outputElectricity()
    delay(1000)
    ##    



def displayElectricity ():
    setCustomText(70, 45, 1000, 1000, str(int(electricity)) + '\tW')



def getElectricityProduction ():
    return PANEL_POWER * Environment.get(ENVIRONMENT_NAME) / 100



def sendReport ():
    report = state # comma seperated states        # var report
    IoEClient.reportStates(electricity)
    setDeviceProperty(getName(), "level", electricity)



def outputElectricity ():
    el_log = math.floor(math.log(electricity) / math.log(LOG_BASE))        # var el_log
    if el_log < 0:
        el_log = 0
    elif el_log > 255:
        el_log = 255
    ##    print(el_log)
    analogWrite(0, el_log)





if __name__ == "__main__":
    setup()
    while True:
        loop()
        sleep(0)


SOLAR PANEL IOT9
from options import Options
from time import *
import math
from physical import *
from gpio import *
from environment import Environment
from ioeclient import IoEClient
#from pyjs import *


#Solar Panel
#Read the sunlight levels
#Output electricity based on sunlight
#Panel will be 160Watts per square meter

#Features output to IoE Server:
# number of kWh of energy produced since turning on
# number of kWh per minute
# current production
ENVIRONMENT_NAME = "Sunlight"        # var ENVIRONMENT_NAME
MULTIPLIER = 255. / 1023        # var MULTIPLIER
MAX_POWER = 1000. #1000 Watts of power based on one meter solar panel at noon at the equator        # var MAX_POWER
EFFICIENCY = 0.16 #About a 16 percent efficiency per solar panel        # var EFFICIENCY
PANEL_POWER = MAX_POWER * EFFICIENCY        # var PANEL_POWER
LOG_BASE = 1.0749111034571373359815489867558        # var LOG_BASE

state = 1        # var state
electricity = 0        # var electricity
#tick = 0        # var tick


def setup ():
    
    IoEClient.setup({
        "type": "Solar",
        "states": [{
            "name": "Status",
            "type": "number",
            "unit": 'Wh',
            "controllable": False
        }]
    })

    IoEClient.onInputReceive ( lambda rinput: processData(rinput, True) )

    sendReport()




def loop ():
    global electricity
    ##    if  (tick++ % 10) is 0 )    # is tick consistent across devices?
    ##    {
    electricity = int(getElectricityProduction())
    ##print(electricity)
    displayElectricity()
    sendReport()
    outputElectricity()
    delay(1000)
    ##    



def displayElectricity ():
    setCustomText(70, 45, 1000, 1000, str(int(electricity)) + '\tW')



def getElectricityProduction ():
    return PANEL_POWER * Environment.get(ENVIRONMENT_NAME) / 100



def sendReport ():
    report = state # comma seperated states        # var report
    IoEClient.reportStates(electricity)
    setDeviceProperty(getName(), "level", electricity)



def outputElectricity ():
    el_log = math.floor(math.log(electricity) / math.log(LOG_BASE))        # var el_log
    if el_log < 0:
        el_log = 0
    elif el_log > 255:
        el_log = 255
    ##    print(el_log)
    analogWrite(0, el_log)





if __name__ == "__main__":
    setup()
    while True:
        loop()
        sleep(0)


WIND DETECTOR
from options import Options
from time import *
import math
from physical import *
from gpio import *
from environment import Environment
from ioeclient import IoEClient


ENVIRONMENT_NAME = "Wind Speed"        # var ENVIRONMENT_NAME
state = 0        # var state
tick = 0        # var tick

# set up client to talk and listen to IoE registration server

def setup ():
    
    IoEClient.setup({
        "type": "Wind Detector",
        "states": [{
            "name": "Wind",
            "type": "bool",
            "controllable": False
        }]
    })
    
    IoEClient.onInputReceive ( lambda rinput: processData(input, True) )

    setState(state)
    sendReport()



# continously checking if WIND exist and send report to registration server

def loop ():
    global tick 

    if tick % 10 == 0: # is tick consistent across devices?
        detect()
        sendReport()
    tick += 1
    


# get WIND variable defined in Environment

def detect ():
    value = Environment.get(ENVIRONMENT_NAME)        # var value

    if value >= 1:
        setState(1)
    else:
        setState(0)


# process data received from server
# not being called since controllable set to False in client setup

def processData (data, bIsRemote):
    if len(data) <= 0:
        return
    data = data.split(",")        # var data
    setState(int(data[0]))


# send wind state  to the server

def sendReport ():
    report = state # comma seperated states        # var report
    IoEClient.reportStates(report)


# set state and update component image to reflect the current state

def setState (newState):
    global state
    if newState == 0:
        digitalWrite(1, LOW)
    else:
        digitalWrite(1, HIGH)

    state = newState

    sendReport()


# toggle wind state

def toggleState ():
    if state == 0:
        setState(1)
    else:
        setState(0)


if __name__ == "__main__":
    setup()
    while True:
        loop()
        sleep(0)

LIGHT IOT23
from gpio import *
from time import *
from physical import *
from ioeclient import *
from environment import *


ENVIRONMENT_IMPACT_DIM = 10
VOLUME_AT_RATE = 100000

state = 0;  # 0 off, 1 low, 2 high
lastTimeInSeconds = 0

def main():
    setup()
    while True:
        loop()

        
def setup():

    IoEClient.setup({
        "type": "Light",
        "states": [
        {
            "name": "Status",
            "type": "options",
            "options": {
                "0": "Off",
                "1": "Dim",
                "2": "On"
            },
            "controllable": True
        }
        ]
    })

    IoEClient.onInputReceive(onInputReceiveDone)
    global state
    add_event_detect(0, detect)
    state = restoreProperty("state", 0)
    setState(state)

def detect():
    processData(customRead(0), False)
    
def onInputReceiveDone(analogInput):
    processData(analogInput, True)
        
def restoreProperty(propertyName, defaultValue):
    value = getDeviceProperty(getName(), propertyName)
    if  not (value is "" or value is None):
        if  type(defaultValue) is int :
            value = int(value)

        setDeviceProperty(getName(), propertyName, value)
        return value
    return defaultValue


def mouseEvent(pressed, x, y, firstPress):
    global state
    if firstPress:
        setState(state+1)

def loop():
    updateEnvironment()
    sleep(1)


def processData(data, bIsRemote):
    if  len(data) <= 0 :
        return
    setState(int(data))


def setState(newState):
    global state
    if newState >= 3 :
        newState = 0
    state = newState

    analogWrite(A1, state)
    customWrite(0, state)
    IoEClient.reportStates(state)
    setDeviceProperty(getName(), "state", state)

def updateEnvironment():
    global VOLUME_AT_RATE
    global ENVIRONMENT_IMPACT_DIM
    volumeRatio = float(VOLUME_AT_RATE) / Environment.getVolume()
    if  state is 0 :
        Environment.setContribution("Visible Light", 0,0, True)
    elif  state is 1:
        Environment.setContribution("Visible Light", ENVIRONMENT_IMPACT_DIM*volumeRatio, ENVIRONMENT_IMPACT_DIM*volumeRatio, False)
    elif  state is 2 :
        Environment.setContribution("Visible Light", ENVIRONMENT_IMPACT_DIM*2*volumeRatio, ENVIRONMENT_IMPACT_DIM*2*volumeRatio, False)

if __name__ == "__main__":
    main()

LIGHT IOT24
from gpio import *
from time import *
from physical import *
from ioeclient import *
from environment import *


ENVIRONMENT_IMPACT_DIM = 10
VOLUME_AT_RATE = 100000

state = 0;  # 0 off, 1 low, 2 high
lastTimeInSeconds = 0

def main():
    setup()
    while True:
        loop()

        
def setup():

    IoEClient.setup({
        "type": "Light",
        "states": [
        {
            "name": "Status",
            "type": "options",
            "options": {
                "0": "Off",
                "1": "Dim",
                "2": "On"
            },
            "controllable": True
        }
        ]
    })

    IoEClient.onInputReceive(onInputReceiveDone)
    global state
    add_event_detect(0, detect)
    state = restoreProperty("state", 0)
    setState(state)

def detect():
    processData(customRead(0), False)
    
def onInputReceiveDone(analogInput):
    processData(analogInput, True)
        
def restoreProperty(propertyName, defaultValue):
    value = getDeviceProperty(getName(), propertyName)
    if  not (value is "" or value is None):
        if  type(defaultValue) is int :
            value = int(value)

        setDeviceProperty(getName(), propertyName, value)
        return value
    return defaultValue


def mouseEvent(pressed, x, y, firstPress):
    global state
    if firstPress:
        setState(state+1)

def loop():
    updateEnvironment()
    sleep(1)


def processData(data, bIsRemote):
    if  len(data) <= 0 :
        return
    setState(int(data))


def setState(newState):
    global state
    if newState >= 3 :
        newState = 0
    state = newState

    analogWrite(A1, state)
    customWrite(0, state)
    IoEClient.reportStates(state)
    setDeviceProperty(getName(), "state", state)

def updateEnvironment():
    global VOLUME_AT_RATE
    global ENVIRONMENT_IMPACT_DIM
    volumeRatio = float(VOLUME_AT_RATE) / Environment.getVolume()
    if  state is 0 :
        Environment.setContribution("Visible Light", 0,0, True)
    elif  state is 1:
        Environment.setContribution("Visible Light", ENVIRONMENT_IMPACT_DIM*volumeRatio, ENVIRONMENT_IMPACT_DIM*volumeRatio, False)
    elif  state is 2 :
        Environment.setContribution("Visible Light", ENVIRONMENT_IMPACT_DIM*2*volumeRatio, ENVIRONMENT_IMPACT_DIM*2*volumeRatio, False)

if __name__ == "__main__":
    main()

FAN
from gpio import *
from time import *
from ioeclient import *
from physical import *
from environment import *
import math
FAN_SPEED_LOW = 0.4; # kph
FAN_SPEED_HIGH = 0.8; # kph
COOLING_RATE = float(-1)/3600; # -1C/hour
HUMDITY_REDUCTION_RATE = float(-1)/3600; # -1%/hour

VOLUME_AT_RATE = 100000;    # the given rates are based on this volume

state = 0;  # 0 off, 1 low, 2 high
level = 0

def main():
    global state
    IoEClient.setup({
        "type": "Ceiling Fan",
        "states": [
        {
            "name": "Status",
            "type": "options",
            "options": {
                "0": "Off",
                "1": "Low",
                "2": "High"
            },
            "controllable": True
        }
        ]
    })

    IoEClient.onInputReceive(onInputReceiveDone)
    add_event_detect(0, detect)
    state = restoreProperty("state", 0)
    setState(state)
    while True:
        delay(1000)

def onInputReceiveDone(data):
    processData(data, True)
    
def detect():
    processData(customRead(0), False)
    
def restoreProperty(propertyName, defaultValue):
    value = getDeviceProperty(getName(), propertyName)
    if  not (value is "" or value is None):
        if  type(defaultValue) is int :
            value = int(value)

        setDeviceProperty(getName(), propertyName, value)
        return value
    return defaultValue

def mouseEvent(pressed, x, y, firstPress):
    if firstPress:
        toggleState()


def processData(data, bIsRemote):
    if  len(data) <= 0 :
        return
    data = data.split(",")
    setState(int(data[0]))

def sendReport():
    global state
    global report
    report = state # comma seperated states
    customWrite(0, report)
    IoEClient.reportStates(report)
    setDeviceProperty(getName(), "state", state)


def setState(newState):
    global state
    analogWrite(A1, newState)
    state = newState

    sendReport()
    updateEnvironment()

def toggleState():
    global state
    state += 1
    if  int(state) >= 3:
        state = 0

    setState(state)

def updateEnvironment():
    global VOLUME_AT_RATE
    global FAN_SPEED_LOW
    global COOLING_RATE
    global HUMDITY_REDUCTION_RATE
    global FAN_SPEED_HIGH
    global state
    volumeRatio = float(VOLUME_AT_RATE) / Environment.getVolume()

    if  int(state) == 0:
        Environment.setContribution("Wind Speed", 0, 0, True)
        Environment.setContribution("Ambient Temperature", 0, 0, True)
        Environment.setContribution("Humidity", 0,0, True)

    elif  int(state) == 1:
        Environment.setContribution("Wind Speed", FAN_SPEED_LOW, FAN_SPEED_LOW, False)

        # everytime the fan restarts, it can do another -100C
        Environment.setContribution("Ambient Temperature", float(COOLING_RATE)/2*volumeRatio, Environment.getCumulativeContribution("Ambient Temperature")-100, True)

        Environment.setContribution("Humidity", float(HUMDITY_REDUCTION_RATE)/2*volumeRatio, Environment.getCumulativeContribution("Humidity")-100, True)
    elif  int(state) == 2:
        Environment.setContribution("Wind Speed", FAN_SPEED_HIGH, FAN_SPEED_HIGH, False)

        Environment.setContribution("Ambient Temperature", float(COOLING_RATE)/2*volumeRatio, Environment.getCumulativeContribution("Ambient Temperature")-100, True)

        Environment.setContribution("Humidity", HUMDITY_REDUCTION_RATE*volumeRatio, Environment.getCumulativeContribution("Humidity")-100, True)

if __name__ == "__main__":
    main()

HUMITURE MONITOR
from gpio import *
from time import *
from physical import *
from ioeclient import *
from environment import *
import math

# Purpose:
# Humiture detector.  Check environmental values to determine and display the humiture.

# Environment must have these two variables in order for this object to work.
# The tempurature must be in degrees fahrenheit.
TEMPERATURE_NAME = "Ambient Temperature"
HUMIDITY_NAME = 'Humidity'

# How temperatures are represented in the Environment.
# If you are storing temperature as C then this would be true.
# If as F then false.  This way the script knows how to convert it when reading from the environment.
METRIC = True


def main():
	setup()
	while True:  
	    loop()
	    
def setup():
    # Necessary for display in a registration server.
    IoEClient.setup({
        "type": "Humitor Sensor",
        "states": [
        {
            "name": "Humitor",
            "type": "number",

            "controllable": False
        }]
    })

# Purpose:
# Update function.  Occures once each update.  Limits how over the temerature is detected to speed up the operation.
def loop():
    detect()
    delay(1000)


# Detects when how temperature is stored in then environment is changed.
# Updates the display and handles the correct measurement type (F or C)
def measurementSystemChangeEvent():
    global METRIC
    METRIC = isUsingMetric()
    if METRIC == True:
    	unit = "C"
    else:
    	unit = "F"

    detect()


# Purpose:
# Check the environmental value and calculate and display the humiture.
def detect():
    global TEMPERATURE_NAME
    global HUMIDITY_NAME
    temperature = Environment.get(TEMPERATURE_NAME)
    humidity = Environment.get(HUMIDITY_NAME)
    if 0 > humidity:
        humidity = 0

    if METRIC:
        temperature = float(temperature * 1.8) + 32

    updateHumiture(temperature,  humidity)



# Purpose:
# Compute the humature and update the text display.
def updateHumiture(temperature, humidity):
    result = float(temperature + humidity)/2
    text = math.floor(result + .5)
    setCustomText(30, 20, 230, 52, text)

    # Update a registration server.
    IoEClient.reportStates(text)
    setDeviceProperty(getName(), "level", text)


if __name__ == "__main__":
    main()

LAWN SPRINKLER
from options import Options
from time import *
import math
from physical import *
from gpio import *
from environment import Environment
from ioeclient import IoEClient
#from pyjs import *


WATERLEVEL_RATE = 0.1 # 0.1 cm per second        # var WATERLEVEL_RATE
HUMIDITY_RATE = 5. / 3600 # 5% per hour        # var HUMIDITY_RATE
VOLUME_AT_RATE = 100000.        # var VOLUME_AT_RATE
MAX_RATE = 1.e6        # var MAX_RATE
state = 0 # 0 off, 1 on        # var state

def setup ():
    global state
    
    IoEClient.setup({
        "type": "Lawn Sprinkler",
        "states": [{
            "name": "Status",
            "type": "bool",
            "controllable": True
        }]
    })

    
    IoEClient.onInputReceive(lambda rinput: processData(rinput, True))

    def on_event_detect(): 
        processData(customRead(0), False)
    add_event_detect(0,  on_event_detect)

    state = restoreProperty("state", 0)
    setState(state)



def restoreProperty (propertyName, defaultValue):
    value = getDeviceProperty(getName(), propertyName)        # var value
    if value:
        if isinstance(defaultValue, (int, float)):
            value = int(value)

        setDeviceProperty(getName(), propertyName, value)
        return value
    

    return defaultValue



def mouseEvent (pressed, x, y, firstPress):
    if firstPress:
        setState(( 0  if state  else 1 ) )



def processData (data, bIsRemote):
    if len(data) <= 0:
        return
    setState(int(data))



def setState (newState):
    global state
    state = newState

    digitalWrite(5, state)
    customWrite(0, state)
    IoEClient.reportStates(state)
    setDeviceProperty(getName(), "state", state)
    updateEnvironment()




def updateEnvironment ():
    if state == 1:
        volumeRatio = VOLUME_AT_RATE / Environment.getVolume()        # var volumeRatio
        Environment.setContribution("Water Level", WATERLEVEL_RATE * volumeRatio, MAX_RATE, True)
        Environment.setContribution("Humidity", HUMIDITY_RATE * volumeRatio, MAX_RATE, True)
    else:
        Environment.setContribution("Water Level", 0, 0, True)
        Environment.setContribution("Humidity", 0, 0, True)


if __name__ == "__main__":
    setup()
    while True:
        #loop()
        sleep(0)

DOOR
from time import *
from physical import *
from gpio import *
from environment import Environment
from ioeclient import IoEClient

ENVIRONMENTS = ["Argon", "CO", "CO2", "Hydrogen", "Helium", "Methane", "Nitrogen", "O2", "Ozone", "Propane", "Smoke"]
ENVIRONMENT_MAX_IMPACT = -0.02 # 2% max when door opens
TEMPERATURE_TRANSFERENCE_MULTIPLIER = 1.25 # increase speed 25% when door open
HUMIDITY_TRANSFERENCE_MULTIPLIER = 1.25
GASES_TRANSFERENCE_MULTIPLIER = 2

doorState = 0 # 0 is closed, 1 is opened
lockState = 0  # 0 is unlocked, 1 is locked

def on_event_detect_0 () :
    processData(customRead(0), False)

def on_input_receive(input) :
    processData(input, True)

def setup ():
    IoEClient.setup({
        "type": "Door",
        "states": [{
            "name": "Open",
            "type": "bool"
        }, 
        {
            "name": "Lock",
            "type": "options",
            "options": {
                0: "Unlock",
                1: "Lock"
            },
            "controllable": True
        }]
    })

    IoEClient.onInputReceive(on_input_receive) 

    add_event_detect(0, on_event_detect_0)

    setDoorState(doorState)
    setLockState(lockState)


def mouseEvent (pressed, x, y, firstPress):
    if firstPress:
        if  isPointInRectangle(x, y, 10,40,5,10) :
            if  lockState == 0 :
                setLockState(1)
            else:
                setLockState(0)
        else:
            if  doorState == 0 :
                openDoor()
            else:
                closeDoor()

def processData (data, bIsRemote):
    if  len(data) < 1 :
        return

    print data

    data = data.split(",")
    doorStateData = int(data[0])
    lockStateData = int(data[1])
    if  lockStateData > -1 :
        setLockState(lockStateData)

    if  doorStateData > -1 and not bIsRemote :
        if  doorStateData == 0 :
            closeDoor()
        else:
            openDoor()


def sendReport ():
    report = str(doorState)+","+str(lockState)    # comma seperated states
    customWrite(0, report)

    IoEClient.reportStates(report)
    setDeviceProperty(getName(), "door state", doorState)
    setDeviceProperty(getName(), "lock state", lockState)


def closeDoor ():
    setDoorState(0)
    updateEnvironment()


def openDoor ():
    if  lockState == 0 :
        setDoorState(1)
        updateEnvironment()
    else:
        print "can't open locked door"


def setDoorState (state):
    global doorState
    if  state == 0:
        digitalWrite(1, LOW)
        setComponentOpacity("led", 1)    # show the led
    else:
        digitalWrite(1, HIGH)
        setComponentOpacity("led", 0)    # hide the led

    doorState = state
    sendReport()


def setLockState (state):
    global lockState
    if  state == 0 :
        digitalWrite(2, LOW)
    else:
        digitalWrite(2, HIGH)

    lockState = state
    sendReport()



def updateEnvironment ():
    rate, emax = 0, 0
    if  doorState == 1:
        for e in ENVIRONMENTS:
            emax = Environment.get(e) * ENVIRONMENT_MAX_IMPACT
            # the emax is reached in an hour, so we divide by 3600 to get seconds
            # then this rate is also based on 100,000 cubic meters (approx. coporate office size)
            rate = emax / 3600 * 100000 / Environment.getVolume()
            Environment.setContribution(e, rate, emax, True)
            Environment.setTransferenceMultiplier(e, GASES_TRANSFERENCE_MULTIPLIER)


        Environment.setTransferenceMultiplier("Ambient Temperature", TEMPERATURE_TRANSFERENCE_MULTIPLIER)
        Environment.setTransferenceMultiplier("Humidity", HUMIDITY_TRANSFERENCE_MULTIPLIER)
    else:
        for e in ENVIRONMENTS:
            Environment.setContribution(e, 0, 0, True)
            Environment.removeCumulativeContribution(e)
            Environment.setTransferenceMultiplier(e, 1)

        Environment.setTransferenceMultiplier("Ambient Temperature", 1)
        Environment.setTransferenceMultiplier("Humidity", 1)



def isPointInRectangle (x,y, rx, ry, width, height):
    if width <= 0 or height <= 0:
        return False
    return (x >= rx and x <= rx + width and y >= ry and y <= ry + height)


if __name__ == "__main__":
    setup()
    while True:
        sleep(0)

WINDOW
from gpio import *
from time import *
from ioeclient import *
from physical import *
from environment import *
import math

ENVIRONMENTS = ["Argon", "CO", "CO2", "Hydrogen", "Helium", "Methane", "Nitrogen", "O2", "Ozone", "Propane", "Smoke"]
ENVIRONMENT_MAX_IMPACT = -0.01; # 2% max when door opens
TEMPERATURE_TRANSFERENCE_MULTIPLIER = 1.20; # increase speed 25% when door open
HUMIDITY_TRANSFERENCE_MULTIPLIER = 1.20
GASES_TRANSFERENCE_MULTIPLIER = 2

state = 0

def main():
	setup()
	while True:
		loop()
#set up client to talk and listen to IoE registration server
def setup():
    IoEClient.setup({
        "type": "Window",
        "states": [{
            "name": "On",
            "type": "bool",
            "controllable": True
        }]
    })

    IoEClient.onInputReceive(onInputReceiveDone)
    add_event_detect(0, detect)
    
    state = restoreProperty("state", 0)
    setState(state)

def onInputReceiveDone(data):
    processData(data, True)
    
def detect():
    processData(customRead(0), false)
    
def restoreProperty(propertyName, defaultValue):
    value = getDeviceProperty(getName(), propertyName)
    if  not (value is "" or value is None):
        if  type(defaultValue) is int :
            value = int(value)

        setDeviceProperty(getName(), propertyName, value)
        return value
    return defaultValue


def mouseEvent(pressed, x, y, firstPress):
    global state
    if firstPress:
        if state == True:
        	setState(0)
        else:
        	setState(1)


#update carbon dioxide and carbon monoxide and send new data to registration server
def loop():
    updateEnvironment()
    delay(1000)


#process data received from server
def processData(data, bIsRemote):
    if  len(data) <= 0 :
        return
    data = data.split(",")
    setState(int(data[0]))


#set state and update component image to reflect the current state
def setState(newState):
    global state
    if  newState is 0 :
        digitalWrite(1, LOW)
    else:
        digitalWrite(1, HIGH)
    
    state = newState
    customWrite(0, state)
    IoEClient.reportStates(state)
    setDeviceProperty(getName(), "state", state)

def updateEnvironment():
    global ENVIRONMENTS
    global ENVIRONMENT_MAX_IMPACT
    global GASES_TRANSFERENCE_MULTIPLIER
    global TEMPERATURE_TRANSFERENCE_MULTIPLIER
    global HUMIDITY_TRANSFERENCE_MULTIPLIER
    global state

    if  state == 1:
        for i in range (0,len(ENVIRONMENTS)):
            max = Environment.get(ENVIRONMENTS[i]) * ENVIRONMENT_MAX_IMPACT
            # the max is reached in an hour, so we divide by 3600 to get seconds
            # then this rate is also based on 100,000 cubic meters (approx. coporate office size)
            rate = float(max) / 3600 * 100000 / Environment.getVolume()
            Environment.setContribution(ENVIRONMENTS[i], rate, max, True)
            Environment.setTransferenceMultiplier(ENVIRONMENTS[i], GASES_TRANSFERENCE_MULTIPLIER)

        Environment.setTransferenceMultiplier("Ambient Temperature", TEMPERATURE_TRANSFERENCE_MULTIPLIER)
        Environment.setTransferenceMultiplier("Humidity", HUMIDITY_TRANSFERENCE_MULTIPLIER)
    else:
        for j in range (0, len(ENVIRONMENTS)):
            Environment.setContribution(ENVIRONMENTS[j], 0, 0, True)
            Environment.removeCumulativeContribution(ENVIRONMENTS[j])
            Environment.setTransferenceMultiplier(ENVIRONMENTS[j], 1)

        Environment.setTransferenceMultiplier("Ambient Temperature", 1)
        Environment.setTransferenceMultiplier("Humidity", 1)

if __name__ == "__main__":
    main()

WATER LEVEL MONITOR
from options import Options
from time import *
import math
from physical import *
from gpio import *
from environment import Environment
from ioeclient import IoEClient
#from pyjs import *


ENVIRONMENT_NAME = "Water Level" # global environment variable to hold the water level        # var ENVIRONMENT_NAME
METRIC = True # use cm when set to true and inch when set to false        # var METRIC
level = 0 # level of water measured in either inch or cm        # var level
# set up metric, initialize state and client to talk to IoE registration server

def setup ():
    global level
    IoEClient.setup({
        "type": "Water Level Monitor",
        "states": [{
            "name": "Water Level",
            "type": "number",
            "unit": "cm",
            "imperialUnit": "in",
            "toImperialConversion": "x/2.54",
            "toMetricConversion": "x*2.54",
            "decimalDigits": 1,
            "controllable": False
        }]
    })
    setState()
    sendReport()


# continuosly detecting water level and send report to server

def loop ():
    measurementSystemChangeEvent()
    detect()
    sendReport()
    delay(1000)


# get WATER_LEVEL measurement defined in Environment

def detect ():
    global ENVIRONMENT_NAME
    value = Environment.get(ENVIRONMENT_NAME)        # var value
    setLevel("%.2f"%(value,))


# send water level in desired metric to the server

def sendReport ():
    global level
    report = level # comma seperated states        # var report
    IoEClient.reportStates(report)
    setDeviceProperty(getName(), "level", report)


# set state and update component image to reflect the current state

def setState ():
    global level
    if level > 0:
        digitalWrite(1, HIGH)
    else:
        digitalWrite(1, LOW)

    sendReport()


# set water level

def setLevel (newLevel):
    global level
    global METRIC
    level = newLevel
    setCustomText(35, 20, 200, 20, str("%.2f"%(convertLength(level, METRIC))))
    setState()

def convertLength (value, isMetric):
    if isMetric:
        return value
    else:
        return float(value) / 2.54
        
def measurementSystemChangeEvent ():
    global METRIC, unit
    METRIC = Options.isUsingMetric()


if __name__ == "__main__":
    setup()
    while True:
        loop()
        sleep(0)




HOME SPEAKER
from time import *
from physical import *
from gpio import *
from environment import Environment
from ioeclient import IoEClient
from pyjs import *

VOLUME_AT_RATE = 100000
SOUND_VOLUME = 65
SOUND_PITCH = 20
SOUND_WHITE_NOISE = 20

# Purpose:
# Home Speaker that can play one of several predefined sounds.
g_sounds = [JsObject({"soundID": 'sound1', "soundPath": '/../Sounds/buzzLow.wav'}),
            JsObject({"soundID": 'sound2', "soundPath": '/../Sounds/buzzMedium.wav'}),
            JsObject({"soundID": 'sound3', "soundPath": '/../Sounds/buzzHigh.wav'})]

g_currSound = -1;

# Purpose:
# Setup the Home Speaker.  Stop any old sounds and add the sounds to use.
def setup():
    global g_currSound
    setDeviceProperty(getName(), 'SOUND_dB', 0)

    IoEClient.setup ({
    "type": 'Home Speaker',
    "states": [{
        "name": 'Signal',
        "type": 'number',
        "controllable": False
        }]
    })

    destroySounds()

    for ind in xrange(0 ,len(g_sounds)):        # var ind
        addSound(g_sounds[ind].soundID, g_sounds[ind].soundPath)

    restoreProperty("SOUND_dB", 0)
    g_currSound = restoreProperty("Signal", -1)


def restoreProperty (propertyName, defaultValue):
    value = getDeviceProperty(getName(), propertyName)
#    print "getting:", propertyName, ": ", value
#    print "default value:", defaultValue
    if  not (value is "" or value == "undefined" or value == None) :
        if  isinstance(defaultValue, (int, float)):
            value = int(value)

#        print "setting:", propertyName, ": ", value
        setDeviceProperty(getName(), propertyName, value)
        return value


    return defaultValue



# Purpose:
# Update function.  Is called once each update.
def loop():
    updateState()
    delay(1000);


# Purpose:
# Update the sound state, reading from the slot and playing the approperiate sound.
def updateState():
    global g_currSound
    playValue = 255*(analogRead(A0)/1023.0)
    if 0 > playValue:
        playValue = 0

    elif playValue > 255:
        playValue = 255
        
    setDeviceProperty(getName(), 'SOUND_dB', int(playValue * (60./255)))

    if -1 != g_currSound:
        stopSound(g_sounds[g_currSound].soundID)


    if 0 == playValue:
        g_currSound = -1
    else:
        g_currSound = int((playValue-1) / (255./len(g_sounds)));


    if -1 is not g_currSound:
        playSound(g_sounds[g_currSound].soundID, 1)

    IoEClient.reportStates(g_currSound)
    setDeviceProperty(getName(), "Signal", g_currSound)
    updateEnvironment()

def updateEnvironment():
    volumeRatio = VOLUME_AT_RATE / Environment.getVolume()
    if g_currSound >= 0:
        Environment.setContribution("Sound Volume", SOUND_VOLUME*volumeRatio, SOUND_VOLUME*volumeRatio, False)
        Environment.setContribution("Sound Pitch", SOUND_PITCH*(g_currSound+1), SOUND_PITCH*(g_currSound+1), False)
        Environment.setContribution("White Noise", SOUND_WHITE_NOISE, SOUND_WHITE_NOISE, False)
    else:
        Environment.setContribution("Sound Volume", 0, 0, False)
        Environment.setContribution("Sound Pitch", 0, 0, False)
        Environment.setContribution("White Noise", 0, 0, False)

if __name__ == "__main__":
    setup()
    while True:
        loop()
        sleep(0)
        
FIRE MONITOR

from options import Options
from time import *
from physical import *
from gpio import *
from environment import Environment
from ioeclient import IoEClient
from pyjs import *
from library import *


# Purpose:
# This is a generic single slot output sensor.
# It can check environment variables, objects properties in range, and send a signal.
# It is designed to have setup functions called that determine how it behaves.
# The setup functions are defined in the library.

# A delay will run each update.  It will be for this amount of time.
# Setting to 0 means there is no delay.
# If making a custom write, you can't have a delay.  customWrite requires the value to be set each loop.
# The custom write thing seems to be a bug in the engine, it should get fixed sometime.
g_delayTime = 1000        # var g_delayTime

# IR wavelength that counts as fire.  760 nm ~ 1100 nm light, etc.

g_sensitivity = JsObject({        # var g_sensitivity
    "low": 760,
    "high": 1100
})

# Purpose:
# Sets the sensor up to look for a device IR and determine if it is a fire.

def setup ():
    setWaitTimeMSec(g_delayTime)
    setupDetectProperty('IR', createPropertySearchDevices(None, 500, 600, 'CENTER'), createDigitalWrite(0))

    setupRegistrationServer('Fire Sensor', 'Fire Detected')
    
    setCallbackOnProcessValue(processValue)


# Purpose:
# Update function.  Calls the library updateSensor which reads environment values, etc
# and sends the value to the slot.

def loop ():
    # Update the sensor.
    updateSensor()


# Purpose:
# This will get called during update with the value before it gets sent to a slot.
# Any modifications you want to do to it should be done here.
# The value returned is what will be sent through the slot.
# value     - The value of the sensor read before it gets sent to a slot. This can be a single value when reading an environment property, or an array if reading a property from devices.
# deviceIDs - the value is an array of device IDs that met the user defined specifications(when requested).  These values match up with the value when finding groups of data (devices).  It is ignored for
#             finding environment variables.

def processValue (value, deviceIDs):
    #print len(value)
    #print value
    # From the readings, determine what is the highest in detection reading in the correct range range and convert to be a strength [0, 255]
    maxInRange = 0        # var maxInRange
    outOfRange = False        # var outOfRange

    for ind in xrange(0, len(value)) :
        if int(value[ind]) > maxInRange:
            maxInRange = int(value[ind])
    
    #print maxInRange, g_sensitivity.low,  g_sensitivity.high
    # Convert the in range value to a digital signal.
    if (g_sensitivity.low <= maxInRange) and\
        (g_sensitivity.high >= maxInRange):
        value = HIGH
    else:
        value = LOW

    #print value
    return value


if __name__ == "__main__":
    setup()
    while True:
        loop()
        sleep(0)

